h2. Getting Started

In this guide, you will create a simple SproutCore "to-do" app called Todos, learning the following:

* how to install SproutCore,
* how to create a SproutCore app,
* how to run the local SproutCore system for development, viewing apps in a browser locally,
* how an app is organized into views, controllers, a statechart, and models,
* how views are created by writing javascript code that specifies layout and presents content,
* how bindings and actions coordinate views with a controller system, which includes a statechart,
* how the controller system ties to models,
* how SproutCore contains powerful programming constructs.

endprologue.

h3. Following Along

You would benefit from carefully following the instructions in this guide, to create directories, to type in code (or to copy and paste it), because it will register in your mind more solidly. However, if you don't have the time or inclination for that, you can access the finished source code for this application on "Github":https://github.com/sproutcore/Todos-Example/, and following along as if you were creating the app manually.

To see Todos in action, click "here":http://github/sproutcore/sproutcore. [TODO] need a demo app url [ATTN: tce]

There is a screencast available on "Vimeo":http://vimeo.com. [TODO] [ATTN: geojeff, who will use ScreenFlow to make a new one]

INFO: Todos is written using a best practices approach. This guide attempts to strike a matter-of-fact tone that doesn't sugar-coat complexity too much, but doesn't attempt to overwhelm. If you need help, please ask questions in IRC or on the mailing list, with references to the numeric heading number for relevant sections of this guide page.

h3. Installing SproutCore

This guide assumes you have successfully installed SproutCore 1.8 with the Mac OS X installer or the Windows installer <a href="http://www.sproutcore.com/install/?redirect=1" onclick="_gaq.push(['_trackEvent', 'Download', 'Guides']);">(Installers)</a>. Or, to install on Linux, try this <link>script</link>. [TODO] Add link to unicolet's Linux script.

h3. Creating A New SproutCore Application

First, in some area of your hard drive where you develop software, make a sproutcore directory: ~/somewhere/sproutcore. This directory can be your place for all things SproutCore. Change directory to ~/somewhere/sproutcore, then create a SproutCore project:

<shell>
$ pwd 
    ~/somewhere/
$ sc-gen project learning_sc

 ~ Created directory at learning_sc
 ~ Created file at learning_sc/Buildfile
 ~ Created file at learning_sc/README

$ cd learning_sc
</shell>

Now you have a learning_sc project directory, ~/somewhere/sproutcore/learning_sc. We will build several SproutCore apps in this project space.

The first app we will make is called Todos. Here is a screen capture of the completed application: [TODO] need Todos screen capture image here.

The Todos app looks simple. It has toolbars at the top and bottom. It has a text field near the top, where a user types in a new todo. It has a list of already added todos. Even such a simple-looking app like this involves the use of intelligent SproutCore programming.

We can describe these intelligent aspects, generally, as the "system of connections" or, in the manner an electrician would use, as the "wiring diagram." SproutCore apps have _bindings_ and between properties of various components of the user interface and those of underlying machinery, and _actions_ coordinated with _states_. 

You see the components of the user interface: checkboxes, buttons, text fields, list views, etc. We'll be looking at the underlying machinery.

This will be the directory structure for the Todos app:

* *learning_sc/* - The project directory, for holding several apps.
** *Buildfile*
** *README.md*
** *apps/*
*** *todos/*
**** *Buildfile*
**** *core.js*
**** *main.js*
**** *theme.js*
**** *statechart.js*
**** *states/*
***** *starting.js*
***** *logging_in.js*
***** *loading_data.js*
***** *showing_app.js*
**** *resources/*
***** *loading.rhtml*
***** *main_page.js*
***** *_theme.css*
***** *body.css*
***** *header.css*
***** *new_todo.css*
***** *todo_item.css*
**** *views/*
***** *todo_item.js*
**** *controllers/*
***** *todos.js*
***** *completed_todos.js*
**** *models/*
***** *todo.js*
**** *en/*
***** *strings.js*
****** *fixtures/*
******* *todo.js*

Here is that directory structure again, with descriptions for each item:

* *learning_sc/*
** *Buildfile*             | _Configuration for the project_ 
** *README.md*             | _Describes your app and how to use it_
** *apps/*
*** *todos/*
**** *Buildfile*           | _Configuration for the Todos app_
**** *core.js*             | _Todos app creation code_
**** *main.js*             | _Adds a data store, and calls the Todos.mainPage view_
**** *theme.js*            | _Adds a Todos.Theme based on the SproutCore Ace theme_
**** *statechart.js*       | _Contains main app states and substates_
**** *states/*
***** *starting.js*        | _A single state, the STARTING state, which plugs in to the app's statechart_
***** *logging_in.js*      | _The LOGGING_IN state (not used in Todos, but there for illustration)_
***** *loading_data.js*     | _The LOADING_DATA state, where data is loaded, and the UI configured_
***** *showing_app.js*     | _The SHOWING_APP state, the general state for responding to user actions_
**** *resources/*
***** *loading.rhtml*      | _A short html file to show when the app is loading_
***** *main_page.js*       | _The Todos.mainPage view_
***** *_theme.css*         | _Contains per directory theme setup_
***** *body.css*           | _Defines css for default page content_
***** *header.css*         | _Defines css for the top toolbar_
***** *new_todo.css*       | _Defines css for the new todo title text field_
***** *todo_item.css*      | _Defines css for todo items in the main list view_
**** *views/*
***** *todo_item.js*       | _TodoItem code for a checkbox and a title_
**** *controllers/*
***** *todos.js*           | _Todos.todosController, an SC.ArrayController to hold todo items_
***** *completed_todos.js* | _Todos.completedTodosController, another SC.ArrayController_
**** *models/*
***** *todo.js*            | _Todos.Todo, the definition of the Todo SC.Record type for the app_
**** *en/*                 | _An English language data directory_
***** *strings.js*         | _Definitions of user interface words in English_
****** *fixtures/* 
******* *todo.js*          | _Fixtures data (for testing the app without hooking to a database_

NOTE: You see that SproutCore is a powerful system, challenging to master, but not so difficult to learn, provided that we take it one step at a time.

We can use the sc-gen command again, to create part of the directory structure shown above for our Todos app:

<shell>
$ pwd 
    ~/somewhere/learning_sc

$ sc-gen statechart_app Todos

 ~ Created directory at apps
 ~ Created directory at apps/todos
 ~ Created file at apps/todos/Buildfile
 ~ Created file at apps/todos/core.js
 ~ Created file at apps/todos/main.js
 ~ Created directory at apps/todos/resources
 ~ Created file at apps/todos/resources/_theme.css
 ~ Created file at apps/todos/resources/loading.rhtml
 ~ Created file at apps/todos/resources/main_page.js
 ~ Created file at apps/todos/statechart.js
 ~ Created directory at apps/todos/states
 ~ Created file at apps/todos/states/ready_state.js
 ~ Created file at apps/todos/theme.js

Your application target is now ready to use!

</shell>

[TODO] USAGE doc for sc-gen has the use of --statechart switch wrong -- you don't need it, because you use statechart_app instead.

h4. Running sc-server to View an App

To take a look at the "Hello World" stage of the Todos app produced by sc-gen, let's learn how to run the sc-server command to view our new app.

<shell>
$ pwd 
    ~/somewhere/learning_sc

$ sc-server
    SproutCore v1.8 Development Server
    Allowing access only from IPs: 127.0.0.1. Use --allow-from-ips='*.*.*.*' to allow all
    Starting server at http://0.0.0.0:4020 in debug mode
    To quit sc-server, press Control-C
    >> Thin web server (v1.2.11 codename Bat-Shit Crazy)
    >> Maximum connections set to 1024
    >> Listening on 0.0.0.0:4020, CTRL+C to stop
    ^C>> Stopping ...
</shell>

Now hit the following url with your favorite modern browser: localhost:4020/todos

You should see a main page the fills the browser window and a single label in the center that says 'Welcome to SproutCore!'.

Stop sc-server with control-C:

<shell>
    ^C>> Stopping ...
</shell>

h4. Buildfiles

There is a project Buildfile in the project directory (~/somewhere/learning_sc) and the Todos app has its own Buildfile in the root app directory (~/somewhere/learning_sc/apps/todos/). Examine the Todos Buildfile and you will see only one configuration line:

    config :todos, :required => :sproutcore

This is Ruby syntax, if you've never seen it. You don't have to know Ruby to do SproutCore development -- it is easy to follow the simple pattern, without having to look up the syntax. This line sets the sproutcore framework reference (:sproutcore) as a configuration dependency for todos. As you work on more complicated apps, you might have other javascript frameworks or special components to require like this. Of course there are many more options that could be set in the Buildfile, but those are for another time.

INFO: SproutCore is a javascript system. The language of the build tools is mostly irrelevant, especially because the build tools work well.

h4. The App Root Directory

There are four .js files in the Todos app root directory (~/somewhere/learning_sc/apps/todos/):

|_. theme.js |_. core.js |_. main.js |_. statechart.js |


Edit these files to assure their content matches that given in the following sections:

h5. theme.js (app root directory)

<javascript filename="in apps/todos/theme.js">
// ==========================================================================
// Project:   Todos
// Copyright: @2012 My Company, Inc.
// ==========================================================================
/*globals Todos */

// This is the theme that defines how your app renders.
//
// Your app is given its own theme so it is easier and less
// messy for you to override specific things just for your
// app.
//
// You don't have to create the whole theme on your own, though:
// your app's theme is based on SproutCore's Ace theme.
//
// NOTE: if you want to change the theme this one is based on, don't
// forget to change the :css_theme property in your buildfile.
Todos.Theme = SC.AceTheme.create({
  name: 'todos'
});

// SproutCore needs to know that your app's theme exists
SC.Theme.addTheme(Todos.Theme);

// Setting it as the default theme makes every pane SproutCore
// creates default to this theme unless otherwise specified.
SC.defaultTheme = 'todos';
</javascript>

Todos.Theme is a derivative of SC.AceTheme, a very nice professional theme. You can override parts of the Ace theme as you wish, or switch it out entirely. Todos.Theme is registered with the system, and a default 'todos' namespace is created.

h5. core.js (app root directory)

<javascript filename="in apps/todos/core.js">
// ==========================================================================
// Project:   Todos
// Copyright: @201X My Company, Inc.
// ==========================================================================
/*globals Todos */
 
/** @namespace
 
  A little todos app.
   
  @extends SC.Object
*/
Todos = SC.Application.create(
  /** @scope Todos.prototype */ {
 
  NAMESPACE: 'Todos',
  VERSION: '0.1.0',
 
  // This is your application store.  You will use this store to access all
  // of your model data.  You can also set a data source on this store to
  // connect to a backend server.  The default setup below connects the store
  // to any fixtures you define.
  store: SC.Store.create().from(SC.Record.fixtures),
  storeType: 'FromFixtures'
 
  // TODO: Add global constants or singleton objects needed by your app here.
 
});
</javascript>

The code in core.js sets up Todos as an instance of SC.Application.

The Todos namespace is Todos: Todos.mainPage, Todos.todosController, etc.

A data store is created from SC.Record.fixtures, which is a way to simulate a real database through reading data given in a fixtures javascript file, which we'll add in a later step. 

The storeType property is set to 'FromFixtures'.

h5. main.js (app root directory)

<javascript filename="in apps/todos/main.js">
// ==========================================================================
// Project:   Todos
// Copyright: @201X My Company, Inc.
// ==========================================================================
/*globals Todos */
 
Todos.main = function main() {
  Todos.statechart.initStatechart();
};
 
function main() { Todos.main(); }
</javascript>

[TODO] sc-gen for statechart creates a main.js with:  SC.RootResponder.responder.set('defaultResponder', statechart); -- do we need this?

main.js for Todos is very simple, with only a line to initialize the statechart. In a larger app, there might be global singleton objects and utility functions generally needed by an app.

h5. statechart.js (app root directory)

<javascript filename="in apps/todos/statechart.js">
// ==========================================================================
// Project:   Todos
// Copyright: @201X My Company, Inc.
// ==========================================================================
/*globals Todos */
 
Todos.statechart = SC.Statechart.create({
 
  rootState: SC.State.design({
    initialSubstate: "STARTING",
 
    STARTING: SC.State.plugin('Todos.STARTING'),
      
    // The LOGGING_IN state is not used in todos. It is here for future reference.
    LOGGING_IN: SC.State.plugin('Todos.LOGGING_IN'),
      
    LOADING_DATA: SC.State.plugin('Todos.LOADING_DATA'),
      
    SHOWING_APP: SC.State.plugin('Todos.SHOWING_APP')

    // More states would go here in a bigger app.
  })
});
</javascript>

The statechart is a defining characteristic of a SproutCore app. Discrete states in a statechart and the transitions between them allow a clean and simple design. In the Todos app statechart, the initial state is STARTING, a not-so-imaginative name! 

There are four states in the Todos statechart: STARTING, LOGGING_IN, LOADING_DATA, and SHOWING_APP. These are defined in individual files in the states directory.

h4. The States Directory

Code for individual states is held in a states directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/
$ cd states
</shell> 

sc-gen created a file called ready_state.js in the states directory. We aren't going to use it for the Todos app, because we'll need several states.

Delete ready_state.js in the apps/todos/states:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/states
$ rm ready_state.js
</shell> 

Files to add in the apps/todos/states directory are:

|_. starting.js |_. logging_in.js |_. loading_data.js |_. showing_app.js |

h5. STARTING State

<javascript filename="in apps/todos/states/starting.js">
// ==========================================================================
// Project:   Todos
// Copyright: @201X My Company, Inc.
// ==========================================================================
/*globals Todos */
 
// For the Todos app, storeType will be 'FromFixtures', so we will
// go directly to the LOADING_DATA state, to prepare for showing the app.
//
Todos.STARTING = SC.State.design({
  enterState: function() {
    if (Todos.get('storeType') === 'FromSomeBackendDatasource') {
      this.gotoState('LOGGING_IN');
    } else if (Todos.get('storeType') === 'FromFixtures') {
      this.gotoState('LOADING_DATA');
    }
  },
 
  exitState: function() {
    // Nothing to worry about here.
  }
});
</javascript>

NOTE: There are different conventions for naming states. The style used here is proven, and the formatting makes the state names prominent. Some people like to camel-case the state names names.

When the statechart is initialized from Todos.main(), program control will go to the STARTING state, specifically to its enterState() function, where there is a check for the storeType. storeType was set to be 'FromFixtures' in core.js, where the data store is instantiated. (Recall that using fixtures data as the datasource is a way to simulate a connection to a real database). You see in the if-else block of STARTING/enterState() that, because storeType === 'FromFixtures', the gotoState() call moves control directly to the LOADING_DATA state, not the LOGGING_IN state, which we won't use in the Todos app. 

h5. LOGGING_IN State

<javascript filename="in apps/todos/states/logging_in.js">
// ==========================================================================
// Project:   Todos
// Copyright: @201X My Company, Inc.
// ==========================================================================
/*globals Todos */
 
// The LOGGING_IN state is not used in todos. It is here for future reference.
//
Todos.LOGGING_IN = SC.State.design({             
  initialSubstate: "SHOWING_LOGIN",
 
  SHOWING_LOGIN: SC.State.design({
 
    enterState: function() {
      // A login panel would be shown now. It would update username and password
      // in a loginController.
    },
 
    exitState: function() {
      // The login panel would be taken down now.
    },
 
    authenticate: function() {
      // The login panel would fire here, and we would call gotoState() to go to
      // another state to do the authentication.
    }
  })
 
  // More states would go here in an app that does authentication.
       
});
</javascript>

INFO: We won't use the LOGGING_IN state in Todos, but have it here for illustration.

h5. LOADING_DATA State

<javascript filename="in apps/todos/states/loading_data.js">
// ==========================================================================
// Project:   Todos
// Copyright: @201X My Company, Inc.
// ==========================================================================
/*globals Todos */
 
Todos.LOADING_DATA = SC.State.design({
  enterState: function() {
    // Set the content property on controllers.
    //
    Todos.todosController.set('content',
      Todos.store.find(SC.Query.local(Todos.Todo, { orderBy: 'timestamp DESC' })));
 
    Todos.completedTodosController.set('content',
      Todos.store.find(SC.Query.local(Todos.Todo, 'isCompleted = true')));
 
    // Done with loading and initialization steps. Move to SHOWING_APP.
    this.gotoState('SHOWING_APP');
  },
 
  exitState: function() {
    // Nothing to worry about in this context.
  }
});
</javascript>

Data content of the two array controllers in the Todos app are set by issuing data query find calls to the store. SC.Query.local() is used because we know we don't have to find the data remotely in the Todos app. We search for todos, referencing the Todos.Todo model (an SC.Record instance). For the primary controller, todosController, we search for all the todos, ordering them by their timestamp property. For the completedTodosController, we search for all the todos for which isCompleted is true. Then we call gotoState() to move to the SHOWING_APP state.

h5. SHOWING_APP State

<javascript filename="in apps/todos/states/showing_app.js">
// ==========================================================================
// Project:   Todos
// Copyright: @201X My Company, Inc.
// ==========================================================================
/*globals Todos */
 
Todos.SHOWING_APP = SC.State.design({
  enterState: function() {
    // Show the mainPage view by appending it.
    //
    Todos.getPath('mainPage.mainPane').append();

    // Put keyboard focus on the new todos item.
    //
    Todos.mainPage.getPath('mainPane.newTodoField.field').becomeFirstResponder();
  },

  exitState: function() {
    // In a larger app, we would do tear-down tasks here.
  },

  // Functions like addTodo are called actions. Their names are used to set the
  // action property of user interface elements such as buttons. In this case,
  // the mainPage view has a newTodoField view that contains a text field and
  // a submit button. The action property of the submit button is set to 'addTodo'.
  // When clicked, this addTodo function will be called.
  //
  // If the user entered some text, which is grabbed from the value property of
  // the associated view of the caller (a text field), addTodo uses this and the
  // current time in a call to store.createRecord() to add a new todo.
  //
  // As the last step, the associated view's value is set to '', so the text
  // field is blank and ready for the next todo.
  //
  addTodo: function (view) {
    var todo = (view.get('value') || '').trim();
    if (todo !== '') {
      Todos.store.createRecord(Todos.Todo, {
        title: todo,
        timestamp: SC.DateTime.create()
      });
      view.set('value', '');
    }
  },

  // Destroys all todo items that are completed.
  //
  // This action method is tied to a button in the mainPage view's bottom
  // toolbar. This button has its action property set to 'clearCompletedTodos',
  // so when the user clicks it, this function is called.
  //
  clearCompletedTodos: function () {
    Todos.completedTodosController.invoke('destroy');
  }
});
</javascript>

The SHOWING_APP state is equivalent to the "ready" state created by sc-gen for a Hello World app. In the enterState() function the mainPage view is appended, which causes it to show in the browser. We want a blinking cursor in the new todo text field. This is accomplished by setting this field to become first responder in the events system.

This state handles two actions, addTodo and clearCompletedTodos. There are references to parts of the view code that will become clear after we add the resources directory, with the mainPage view and associated files, and other view and system components. Look back to the state and statechart code as we move through the rest of the guide.

h4. The Resources Directory

We've covered the highest-level parts of the app defined in the statechart. Now let's add the rest. 

The mainPage view, CSS files, a theme file, and an html page live in a directory called resources.  Go to that directory now:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/
$ cd resources
</shell> 

Files to add in the apps/todos/resources directory are:

|_. main_page.js |_. header.css |_. body.css |_. new_todo.css |_. todo_item.css |_. _theme.css |_. loading.rhtml |

h5. main_page.js (resources directory)

<javascript filename="in apps/todos/resources/main_page.js">
// ==========================================================================
// Project:   Todos - mainPage
// Copyright: @2012 My Company, Inc.
// ==========================================================================
/*globals Todos */
require('views/todo_item');

// This page describes the main user interface for your application.  
Todos.mainPage = SC.Page.design({

  // The main pane is made visible on screen as soon as your app is loaded.
  // Add childViews to this pane for views to display immediately on page 
  // load.
  mainPane: SC.MainPane.design({
    childViews: ['header', 'newTodoField', 'todosList', 'footer'],
    defaultResponder: "Todos.statechart", 

    header: SC.ToolbarView.design({
      layout: { centerX: 0, width: 500, top: 0, height: 36 },

      childViews: ['title', 'completeAll'],

      completeAll: SC.CheckboxView.design(SC.AutoResize, {
        autoResizePadding: { width: 47 },
        localize: YES,
        title: '_Mark all as done',
        valueBinding: 'Todos.completedTodosController.areAllCompleted'
      }),

      title: SC.LabelView.design({
        layout: { left: 0, right: 0, top: 0, bottom: 0 },

        totalTodoBinding: SC.Binding.oneWay('Todos.todosController.length'),
        completedTodosBinding: SC.Binding.oneWay('Todos.completedTodosController.length'),

        value: function () {
          var leftTodo = this.get('totalTodo') - this.get('completedTodos');
          return 'Todos (%@)'.loc(leftTodo);
        }.property('totalTodo', 'completedTodos').cacheable()
      })
    }),

    newTodoField: SC.View.design({
      classNames: ['new-todo'],
      layout: { centerX: 0, width: 500, top: 36, height: 36 },
      childViews: ['field', 'submit'],

      field: SC.TextFieldView.design({
        localize: YES,
        hint: '_What needs to be done?'
      }),

      submit: SC.ButtonView.design(SC.AutoResize, {
        controlSize: SC.HUGE_CONTROL_SIZE,
        layout: { right: 12, height: 30, centerY: 0, zIndex: 100 },
        localize: YES,
        title: '_Add',
        action: 'addTodo',
        valueBinding: '.parentView.field.value',
        isDefaultBinding: '.parentView.field*focused'
      })
    }),
    
    todosList: SC.ScrollView.design({
      layout: { centerX: 0, width: 500, top: 72, bottom: 36 },
      contentView: SC.ListView.design({
        contentBinding: SC.Binding.oneWay('Todos.todosController'),
        rowHeight: 36,
        exampleView: Todos.TodoItemView
      })
    }),
        
    footer: SC.ToolbarView.design({
      layout: { centerX: 0, width: 500, bottom: 0, height: 36 },

      childViews: ['clearCompletedTodos'],
      clearCompletedTodos: SC.ButtonView.design(SC.AutoResize, {
        controlSize: SC.HUGE_CONTROL_SIZE,
        layout: { left: 14, height: 30, centerY: 0 },
        isEnabledBinding: SC.Binding.oneWay('Todos.completedTodosController.length').bool(),
        localize: YES,
        title: '_Clear completed todos',
        action: 'clearCompletedTodos'
      })
    })
  })

});
</javascript>

There are four parts to the Todos mainPage view: a header and footer, and between them are a newTodoField and a todosList. A user types a new todo in the newTodoField, and when they click the submit button, labeled 'Add', the new todo is added by means of the todosController's addTodo() function. The new todo will, in turn, show up in the todosList. How does this happen? Look at the lines that have Binding in the property names. When you write user interface element code, you "wire up" these connections with such binding instructions. 

h6. Toolbars in header and footer

The header view is an SC.ToolbarView with two child views: a completeAll checkbox view and a title label view. The valueBinding property of the checkbox is tied to an areAllCompleted() function in the completedTodosController, which answers that question -- if yes, then the completeAll checkbox will show as checked. This is a two-way binding, so it works in reverse. If the user clicks the completeAll checkbox, then areAllCompleted() will set isCompleted to true for all todos. Yes, that makes areAllCompleted() a very special type of function, called a computed property. As you'll see, computed properties give this power in more than one context.

The footer view has a single child view, clearCompletedTodos, a button whose action is tied to the clearCompletedTodos() function in the completedTodosController. The isEnabledBinding property has a one-way binding (faster, if you don't need two-way, reciprocal updating) to the length of the completedTodosController, which is an SC.ArrayController. If its length is 0, then isEnabled is false and the button will not be active (If there aren't any todos, there is nothing to clear).

h6. newTodoField

The newTodoField view contains a text field called field and a submit button. The submit button has two properties that are bound to the associated text field. The valueBinding property is bound to field.value, which of course is the text the user enters. Note the use of .parentView in the valueBinding definition. In this context, parentView refers to the newTodoField view, which has the field and submit child views. The isDefaultBinding property works in similar fashion, but you note an asterisk in front of a reference to 'focused', which is one of the boolean properties available for a text field. The asterisk is a convention that means what an asterisk often means -- if the text field has any type of focus at all, keyboard or mouse, then 'focused' will be true. 
 
h6. todosList

The todosList view follows the SproutCore idiom for wrapping an SC.ListView in an SC.ScrollView. The contentBinding property of the list is set to Todos.todosController. The exampleView property introduces a concept very important for SproutCore: views can be defined in separate javascript files, often held in a views directory, and included where they are needed. exampleView is set to Todos.TodoItemView, which necessitates a require statement at the top of the file: require('views/todo_item');. TodoItemView has a checkbox and label. We'll add it after we add the views directory later.

h5. _theme.css (resources directory)

<css filename="in apps/todos/resources/_theme.css">
/*
  This defines the global $theme variable for use inside your CSS.
  The $theme variable holds the CSS class names for your theme.
  
  You can then theme your app by using CSS like this:

      $theme.button {
        color: blue;
        @include slices('white-button.png', $left: 3, $right: 3);
      }
  
  Any _theme.css file is prepended to all files inside its directory,
  and any subdirectories that don't define their own _theme.css file.
  
  This allows you to give different directories different values for
  $theme if you wish.
*/
$theme: '.ace.todos';
</css>

The underscore starting the name of _theme.css is a dead giveaway that it must apply in some special way to the theming system. It defines $theme to be our Ace-derived theme, ace.todos. You'll see $theme used in individual content CSS files.

h5. Content CSS files

You can add a single CSS file in your resources directory, or you can add many small ones. For the Todos app, we'll choose the many-small-ones approach. In these CSS files, where you see something like $theme.sc-text-field-view, the sc- prefix indicates an override of the sc- CSS definitions in the Ace theme. 

NOTE: CSS is an art unto itself, an important side of doing SproutCore development and building views.

Names of the files indicate their applicability: header.css, body.css, new_todo.css, and todo_item.css.

h6. header.css (resources directory)

<css filename="in apps/todos/resources/header.css">
$theme.toolbar {
  .checkbox {
    .button {
      left: 13px;
      top: 50%;
      margin-top: -8px;
    }

    .label {
      left: 47px;
      line-height: 36px;
    }
  }

  .sc-label-view {
    text-align: right;
    line-height: 36px;
    font-weight: bold;
    font-size: 18px;
    padding-right: 12px;
  }
}
</css>

h6. body.css (resources directory)

<css filename="in apps/todos/resources/body.css">
body {
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizelegibility;
}

.sc-pane {
  -webkit-transform: none;
}
</css>

h6. new_todo.css (resources directory)

<css filename="in apps/todos/resources/new_todo.css">
$theme.new-todo {
  background-color: #FFF;
}

$theme.sc-text-field-view {
  background-color: transparent;
  font-size: 14px;

  .padding {
    left: 14px;
  }
}
</css>

h6. todo_item.css (resources directory)

<css filename="in apps/todos/resources/todo_item.css">
$theme.todo-item {
  .button {
    left: 13px;
    top: 50%;
    margin-top: -8px;
  }

  .label {
    left: 47px;
    line-height: 36px;
  }

  &.sel {
    background-color: white;
    color: #AAA;
    text-decoration: line-through;
  }
}
</css>

h5. loading.rhtml (resources directory)

SproutCore apps can weigh in north of the welterweight class, so while the app is loading we may need to show a loading indicator. For todos we don't have to worry, but in larger apps, this file could need some attention.

<html filename="in apps/todos/resources/loading.rhtml">
<% content_for :loading do %>
<% # Any HTML in this file will be visible on screen while your page loads
   # its application JavaScript.  SproutCore applications are optimized for 
   # caching and startup very fast, so your users will often only see this 
   # content for a brief moment on their first app load, if at all.
%>
<p class="loading">Loading...<p>

<% end %>
</html>

h4. The Views Directory

sc-gen doesn't make a views directory, so we'll need to make one.

Before adding the views directory, some navigation is needed. We are still in the resources directory, so move back up to the todos app root directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/resources/
$ cd ..
</shell>

Make a views directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/
$ mkdir views
$ cd views
</shell>

The views directory will contain one file: 

|_. todo_item.js |

h5. todo_item.js (views directory)

<javascript filename="in apps/todos/views/todo_item.js">
Todos.TodoItemView = SC.CheckboxView.design({
  // The CSS class names to apply to this view
  classNames: ['todo-item'],

  valueBinding: '.content.isCompleted',

  titleBinding: SC.Binding.oneWay('.content.title')
});
</javascript>

TodoItemView is a checkbox, which has a label. You see a bit of wiring to CSS in the classNames property, an array of CSS class names. valueBinding has a reference to .content.isCompleted, prompting an explanation of the context for this view. We know that this view is defined as the exampleView property of the todos list above. The term example here means "the view to use for each list item." List items for the todos list are todos, which are defined in the Todos.Todo model. So, .content used in the TodoItemView definition refers to a single todo item in the list. The value of this checkbox is thus the isCompleted property of the todo associated with the given list item. Likewise, titleBinding is tied to the title property of the list item todo.

So, you really have to think about where this view is used to understand it, but that comes with the territory of having separate views in files in a views directory. It helps to name such views as SomethingItemView, because the Item part indicates the use in a list. 

h4. The Models Directory

sc-gen does not make a models directory, so we'll need to make it.

Move up to the app root directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/resources/views/
$ cd ..
</shell>

Make a models directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/
$ mkdir models
$ cd models
</shell>

SproutCore models are based on SC.Record, which offers a substantial set of data definition and processing functionality.

The models directory will contain one file:

|_. todo.js |

h5. todo.js (models directory)

<javascript filename="in apps/todos/models/todo.js">
require('core');

// A simple SproutCore model that describes
// the semantics of something that needs to be done.
Todos.Todo = SC.Record.extend({

  // When was this Todo created?
  timestamp: SC.Record.attr(SC.DateTime),

  // Is the Todo item completed?
  isCompleted: SC.Record.attr(Boolean),

  // What is it that needs to be done?
  title: SC.Record.attr(String)

});
</javascript>

The Todo model has three properties: timestamp, isCompleted, and title. All are defined using the SC.Record.attr() helper (convenience) function, where builtin javascript types and Sproutcore types may be specified. There is much more that could be done in these property definitions, but for Todos, the basic types and their defaults will suffice.

h4. The Controllers Directory

sc-gen does not make a controllers directory, so we'll make it.

Move up to the todos app root directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/models
$ cd ..
</shell>

Make a controllers directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/
$ mkdir controllers
$ cd controllers
</shell>

Controllers tied to models mediate communication with views. We'll need a couple in the Todos app.

The controllers directory will contain two files: 

|_. todos.js |_. completed_todos.js |

h5. todos.js (controllers directory)

<javascript filename="in apps/todos/controllers/todos.js">
require('core');
 
// A controller that will provide a list of all of the todos.
Todos.todosController = SC.ArrayController.create({
});
</javascript>

h5. completed_todos.js (controllers directory)

<javascript filename="in apps/todos/controllers/completed_todos.js">
require('controllers/todos');

// The todo manager is a list of all todo items that have `isCompleted` set to `YES`.
Todos.completedTodosController = SC.ArrayController.create({

  // The total number of Todos
  totalTodosBinding: SC.Binding.oneWay('Todos.todosController.length'),

  // Whether all items in the Todo list are completed
  areAllCompleted: function (k, v) {
    if (v !== undefined) {
      Todos.todosController.setEach('isCompleted', v);
    }
    return this.get('length') === this.get('totalTodos');
  }.property('length', 'totalTodos').cacheable()

});
</javascript>

The todosController has the simplest default definition as an SC.ArrayController. An array controller has a default _content_ reference to the data: you don't see a content property defined here, but take note, because you'll see prevalent use of the content property in all things controller.

The completeTodosController is another array controller with a property, totalTodosBinding, and a function, areAllCompleted(). 

totalTodosBinding is simple enough. It is a one-way binding (we are "pulling", we don't care about pushing back) to the length of the todosController array controller. We need a local reference to this length, because we are about to do something impressive, in part based on it.

areAllCompleted() is a function, but a very special type of function, called a computed property. Note the .property() call hanging on the end of the function definition. This gives 'length' and 'totalTodos' as parameters, then tacks on .cacheable(). First, the parameters, which are references to local properties for this context, which is the array controller body. We know we have a 'length' property -- this is an array controller. But what gives with the use of the 'totalTodos' reference, isn't the property called totalTodosBinding? Ah, the answer is that anytime Binding is appended to a property name, you have a kind of dual-property arrangement. The actual property is, in fact, totalTodos. In defining totalTodosBinding, we essentially say, get the value of totalTodos from this other source. That covers the background on mechanics of property names, now to address what .property('length', 'totalTodos').cacheable() accomplishes. It means:

  "Base this computed property on the length and totalTodos properties, and update it if either of them changes, and, oh, by the way, please cache the values while you are at it, so unnecessary updates aren't performed." 

There is more to explain about the working of this computed property. What are the k and v parameters, and what does the internal code do? k and v are key and value. On a call, if v is a defined value, then the totalTodos value is being changed. This is a mandate to try to mark all todos as completed by this value. That's the name of the function/computed property: areAllCompleted. If a call is made to set it, then the body of the function needs to update the data accordingly. If v evaluates to true, then isCompleted for each todo item will be set and all the checkboxes will be checked in the list. That explains what the if block does. 

Notice the return at the end of the areAllCompleted computed property function. We return the result of a test comparing the length of completed todos array (the local 'length') to the length of the todos array (the local 'totalTodos', which is bound to an external source, the full todosController array). If these lengths are the same, then all todos have been marked as completed, otherwise no. 

So, a computed property used in this way is both a setter and a getter. Once you get the hang of making these you realize the benefit: automatic updating and caching for efficiency.

h4. The En Directory

sc-gen does not make an en directory, nor its fixtures directory. We'll make these.

Move up to the todos app root directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/controllers/
$ cd ..
</shell>

Make an en directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/
$ mkdir en
$ cd en
</shell>

h5. strings.js (en directory)

The en directory will contain one file: 

|_. strings.js |

<javascript filename="in apps/todos/en/strings.js">
// ==========================================================================
// Project:   Todos Strings
// Copyright: Â©2011 SproutCore
// ==========================================================================
/*globals Todos */

// Place strings you want to localize here.  In your app, use the key and
// localize it using "key string".loc().  HINT: For your key names, use the
// english string with an underscore in front.  This way you can still see
// how your UI will look and you'll notice right away when something needs a
// localized string added to this file!
//
SC.stringsFor('en', {
  '_Mark all as done': 'Mark all as done',
  '_Todos (%@)': 'Todos (%@)',
  '_Clear completed todos': 'Clear completed Todos',
  '_Add': 'Add',
  '_What needs to be done?': 'What needs to be done?'
});
</javascript>

h5. The Fixtures Directory

While still in the en directory, make a fixtures directory:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/en/
$ mkdir fixtures
$ cd fixtures
</shell>

The fixtures directory will contain one file: 

|_. todo.js |

h6. todo.js (fixtures directory)

<javascript filename="in apps/todos/en/fixtures/todo.js">
require('models/todo');

Todos.Todo.FIXTURES = [
 {
   guid: 0,
   isCompleted: YES,
   title: 'Add a SHOWING_APP state'
 },
 {
   guid: 1,
   isCompleted: YES,
   title: 'Edit the buildfile'
 },
 {
   guid: 2,
   isCompleted: YES,
   title: 'Add a todos app'
 },
 {
   guid: 3,
   isCompleted: YES,
   title: 'Install SproutCore'
 }
];
</javascript>

h4. Running the App

Now we can run the app, which we should do from the project root directory, where the Buildfile lives:

<shell>
$ pwd 
    ~/somewhere/learning_sc/apps/todos/en/fixtures
$ cd ../../../..
</shell>

And run it!

<shell>
$ pwd 
    ~/somewhere/learning_sc/
$ sc-server
</shell>

Visit http://localhost:4020/ in your favorite modern browser and you should see a list of apps, including Todos. 


* March 1, 2011: initial version by "Tom Dale":credits.html#tomdale and "Yehuda Katz":credits.html#wycats
* March 2, 2011: fixed formmating and added paths to filenames by "Topher Fangio":credits.html#topherfangio and "Peter Wagenet":credits.html#pwagenet
* March 22, 2011: cleaned up demo based on new features by "Yehuda Katz":credits.html#wycats
* April 11, 2011: consistently use view classes and extend, update to reflect better Handlebars integration by "Yehuda Katz":credits.html#wycats and "Tom Dale":credits.html#tomdale
* May 6, 2011: clarifications, minor inconsistency fixes, updated CSS for older browsers, plus new mobile section by "Tyler Keating":credits.html#publickeating
* May 9, 2011: update for recent changes in SproutCore 1.6 by "Tom Dale":credits.html#tomdale and "Yehuda Katz":credits.html#wycats
* February 27, 2012: rewrite for SproutCore 1.8 by the 1.8 release sprint team, including the following who worked on this task: "Tim Evans":credits.html#tce, "Tyler Keating":credits.html#publickeating, "Maurits Lamers":credits.html#mauritslamers, "Jeff Pittman":credits.html#geojeff

