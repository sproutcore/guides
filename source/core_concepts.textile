h2. Core Concepts

The guide covers some of the core concepts of SproutCore. By referring to this guide, you will be able to:

* Understand how classes work, including +SC.Object+
* Be familiar with Properties, Observers, Bindings and the Run Loop
* Write your own classes based on +SC.Object+ with full use of Observers and Bindings
* Know when to worry about the Run Loop

endprologue.

h3. +SC.Object+ and Classes

SproutCore maintains a traditional "object-oriented structure":http://en.wikipedia.org/wiki/Object-oriented_programming at the root of which lies +SC.Object+. +SC.Object+ defines all the basic features needed by a class in SproutCore. These include Properties, Observers and Bindings, which I will go into detail on below.

h4. Creating an +SC.Object+ Instance

Creation of an +SC.Object+ instance is straightforward.

<javascript>
var obj = SC.Object.create()
</javascript>

In most cases you will want to create your SC.Object with some pre-set properties. You accomplish this by providing the properties in a hash.

<javascript>
var person = SC.Object.create({
  firstName: 'Peter',
  lastName:  'Wagenet'
});
person.get('firstName'); // Peter
person.get('lastName');  // Wagenet
</javascript>

NOTE: We will explain the +get+ and +set+ functions in more detail later. For now, it's worth getting in the habit of using them.

h4. Creating an +SC.Object+ Subclass

In many cases you will want to create subclasses of +SC.Object+ to handle similar objects. In the above example, we created a person. Normally, however, it would make sense to create a +Person+ class, and then to create objects from it. In order to do this, we make a subclass of SC.Object

<javascript>
MyApp.Person = SC.Object.extend({
  firstName: null,
  lastName:  null,

  fullName: function(){
    return this.get('firstName')+' '+this.get('lastName');
  }
});
</javascript>

You could then create an instance of the +Person+ class, and it would contain the properties 'firstName' and 'lastName', and the function 'fullName'. 

<javascript>
var person = MyApp.Person.create({
  firstName: 'Peter',
  lastName:  'Wagenet'
});
person.fullName(); // Peter Wagenet
</javascript>

NOTE: In SproutCore, the fullName() function would probably be defined as a 'computed property', to allow for things like caching and key value observing. We'll discuss this below.

h5. Calling super methods with +sc_super+

In some cases when you subclass an object you will want to augment a method of the parent class without completely overriding it. In this case, SproutCore provides the +sc_super+ method which calls the original function. +sc_super+ is functionally very similar to the 'super' method in, for instance, Ruby.

<javascript>
MyApp.FormalPerson = MyApp.Person.extend({
  title: null,
  fullName: function(){
    return this.get('title')+' '+sc_super();
  }
});
var person = MyApp.FormalPerson.create({
  title:     'Mr.',
  firstName: 'Peter',
  lastName:  'Wagenet'
});
person.fullName(); // Mr. Peter Wagenet
</javascript>

+sc_super+ can also pass arguments onwards.

NOTE: +sc_super+ is one of the rare exceptions in SproutCore in that it is not actually a real JavaScript function. It's just a pre-processor directive that gets replaced with +arguments.callee.base.apply(this, arguments)+.

h5. The +init+ method

Whenever an instance of +SC.Object+ is created, the +init+ method is called. This function can be overridden when you need to perform some setup functionality when creating your object.

<javascript>
MyApp.Calculation = SC.Object.extend({
  input: null,
  result: null,

  _calculate: function(){
    // Do expensive calculation
    this.set('result', this.get('input') * 2);
  },

  init: function(){
    sc_super();
    this._calculate();
  }
});
var calc = MyApp.Calculation.create({ input: 5 });
calc.result; // 10
</javascript>

NOTE: By convention private properties and functions are prefaced with an underscore.

WARNING: When overriding +init+ it is important that you call +sc_super+ at the start of your custom +init+ method. This will make sure that all internal object initialization takes place as expected.

h5. Using Mixins

Mixins are an easy way to extend multiple classes that don't share an inheritance tree with similar functionality. Mixins are just a hash with a series of properties that will be added to the class you create.

<javascript>
MyApp.Friendly = {
  sayHello: function(){
    return 'Hello, my name is '+this.name;
  }
};
</javascript>

To add one or more mixins to a hash, add them as parameters to extend:

<javascript>
MyApp.Person = SC.Object.extend(MyApp.Friendly, {
  name: null;
});
var person = MyApp.Person.create({ name: 'Bob' });
person.sayHello(); // Hello, my name is Bob
</javascript>

NOTE: As you may have guessed, +SC.Object.extend+ just takes a series of hashes and mixes them all in to a newly created class.

h5. Class methods

You can also define class methods on your custom classes. If you need to add a single class method to a class, you can do it in the traditional Javascript manner.

<javascript>
MyApp.Person.quickCreate = function(firstName, lastName){
  return MyApp.Person.create({
    firstName: firstName,
    lastName: lastName
  });
};
var person = MyApp.Person.quickCreate('Peter', 'Wagenet');
person.fullName(); // Peter Wagenet
</javascript>

However, sometimes you may want to add a series of class methods or properties. In this case you can use the mixin method. Note, that the mixin method is different from the 'mixins' described above. The mixin method will add the properties and methods within the block as class properties and methods. Mixins themselves add instance variables and methods.

<javascript>
MyApp.Person.mixin({
  quickCreate: function(firstName, lastName){
    return MyApp.Person.create({
      firstName: firstName,
      lastName: lastName
    });
  }),

  // Additional properties
});
person = MyApp.Person.quickCreate("Mary","Shelley");
person.fullName(); // Mary Shelley
</javascript>

h3. Properties, Bindings and Observers

Properties, Bindings and Observers all make up what is known as the Key-Value Observing (KVO) system of SproutCore.

h4. Getters and Setters

For KVO to work properly, SproutCore implements getters and setters to track changes to objects. This is why it's important to use +get+ and +set+ for any properties that might use observers, bindings, or computed properties. Failure to do so will quickly cause your app to get out of sync. I know this may sound like a bit of a pain, but don't worry, you'll quickly get used to using +get+ and +set+ and you'll forget you ever had to worry about it.

<javascript>
var obj = SC.Object.create({ name: 'Jim' });
obj.get('name'); // Jim
obj.set('name', 'Bob');
obj.get('name'); // Bob
</javascript>

NOTE: Those of you who have worked in languages like Java may be familiar with having to write property accessors. Instead of having to define accessors for every property, +get+ and +set+ function as universal accessors.

h4. Computed Properties

Sometimes you may have properties that depend on other properties. These are known as computed properties. Computed properties are defined as functions with a call to +property+ and a list of the dependent properties.

<javascript>
MyApp.Person = SC.Object.extend({
  firstName: null,
  lastName:  null,

  fullName: function(){
    return this.get('firstName')+' '+this.get('lastName');
  }.property('firstName', 'lastName')
});
var person = MyApp.Person.create({
  firstName: 'Peter',
  lastName:  'Wagenet'
});
person.get('fullName'); // Peter Wagenet
person.set('lastName', 'Smith');
person.get('fullName'); // Peter Smith
</javascript>

As you can see, you are able to use +get+ with computed properties in the same way you would use it with normal ones.

Setting computed properties is slightly more complicated, but still easy to grasp. The +keyName+ and +value+ are passed in as the first two arguments to the property function. The +get+ function will call a computed property with this +value+ set to +undefined+, where the +set+ function will set +value+ to the property given in the parameters to set.

<javascript>
MyApp.Capitalizer = SC.Object.extend({
  capitalizedValue: function(keyName, value){
    if (value !== undefined) {
      this._capitalizedValue = value.toUpperCase();
    }
    return this._capitalizedValue;
  }.property()
});
var cap = MyApp.Capitalizer.create();
cap.set('capitalizedValue', 'abc'); // Calls capitalizedValue with value set to 'abc'. Sets the value, then returns ABC.
cap.get('capitalizedValue'); // Calls capitalizedValue with value set to undefined. Returns ABC.
</javascript>

NOTE: In most cases you will find you can just ignore the +keyName+ parameter. Also, when the function is called via +get+, +value+ will be +undefined+.

h4. Property Paths

SproutCore also introduces the concept of property paths. A property path is a string that points to a nested property. For instance +"MyApp.userController.firstName"+ refers to the +firstName+ property on the +MyApp.userController+ object. You can also have relative paths which refer paths relative to the current object. For instance, within the context of +MyApp+, you could use +".userController.firstName"+ to point to the same location. As you can see, the relative property begins with a period. This will always be true of relative properties.

To work with relative property paths you can use the +getPath+ and +setPath+ functions. These work identically to +get+ and +set+ except they expect a path for the first argument.

In addition to +getPath+ and +setPath+ you will also see property paths used for observers and bindings, which we will explain below.

h3. Observers

Closely related to the concept of properties is that of observers. Observers do exactly what their name suggests, they observe properties, watching for changes. The most basic observer looks like this:

<javascript>
var obj = SC.Object.create({
  value: null,
  valueDidUpdate: function(){
    alert('New Value: '+this.get('value'));
  }.observes('value')
});
obj.set('value', 'Test');
// alert('New Value: Test');
</javascript>

As you can see +observes+ is called on a function and when the property is updated the function is called. You can also pass multiple properties into an observer.

<javascript>
MyApp.Person = SC.Object.extend({
  firstName: null,
  lastName: null,

  nameDidChange: function() {
    alert('The Name changed!');
  }.observes('firstName','lastName');
});
person = MyApp.Person.create({
  firstName: 'Emma',
  lastName: 'Goldman'
});
person.set('lastName','Berkman'); //alert('The Name changed!')
person.set('firstName','Alexander'); //alert('The Name changed!')
</javascript>

Observers will also accept property paths to observe.

h4. Observer Notification

It is important to realize that observers have to be notified of property changes. The +set+ method handles this for us automatically - this is one of the reasons +get+ and +set+ should be used to access properties. However, there are cases where using +set+ doesn't work. In these cases you can use +notifyPropertyChange+ to tell observers that the property has been updated, i.e. +this.notifyPropertyChange('value')+.

In some cases you may find that you are updating a number of properties at once. If you have a lot of observers that depend on these properties, you may find them getting called more often than necessary. In this case, you can use +beginPropertyChanges+ and +endPropertyChanges+ to wrap the your property change calls. This will cause all change notifications to happen once +endPropertyChanges+ is called and will prevent unnecessary duplicate notifications.

h4. Chained Property Paths

Observers and bindings also use a special type of property path called a chained property path. When using an observer or binding, usually the actual observer is only added to the the second to last object in the property path. So, if your path is +"MyApp.usersController.mainUser.name"+ then SproutCore finds the object at +"MyApp.usersController.mainUser"+ and then adds an observer for its +name+ property. However, nothing is observing +MyApp.usersController+ to see if +mainUser+ changes to a different user. For example:

<javascript>
MyApp.usersController = SC.ArrayController.create({
  mainUser: SC.Object.create({
    name: 'Joe'
  })
});

MyApp.observerObject = SC.View.create({
  userNameDidChange: function(){
    alert(this.getPath('MyApp.usersController.mainUser.name'));
  }.observes('MyApp.usersController.mainUser.name')
});

MyApp.usersController.setPath('mainUser.name', 'Jim'); // alert('Jim')
MyApp.usersController.set('mainUser', SC.Object.create({ name: 'Bob' })); // No alert
</javascript>

As you can see, when we replace +mainUser+ the observer does not fire.  This is because we only have an observer on the the original user object.  We are not watching for changes to +usersController+.

What we want to do is watch for changes to +usersController.mainUser+ and for changes to +mainUser.name+. This is where chained property paths come in. To let SproutCore know that we want to observe for both changes, we use

<javascript>MyApp.usersController*mainUser.name</javascript>

The asterisk (+*+) in the property path indicates that we want SproutCore to observe changes to all properties following the asterisk. In this case, that is both +mainUser+ and +name+. This is known as a chained observer.

Here's an updated version of the previous example with a chained observer:

<javascript>
MyApp.observerObject = SC.View.create({
  userNameDidChange: function(){
    alert(this.getPath('MyApp.usersController.mainUser.name'));
  }.observes('MyApp.usersController*mainUser.name') // We have added an asterisk to this line
});

MyApp.usersController.setPath('mainUser.name', 'Jim'); // alert(Jim)
MyApp.usersController.set('mainUser', SC.Object.create({ name: 'Bob' })); // alert('Bob')
</javascript>

The observer will now fire if +MyApp.usersController.mainUser.name+ changes, or the +MyApp.usersController.mainUser+ object itself is changed.

So why don't we always use chained observers? Observers are expensive and often times we don't care about changes in all levels. In the previous example, we don't care about changes to +MyApp.usersController+. The controller is set once and won't ever change through the lifetime of the application. Had we defaulted to chained observers we would also be observing this, which isn't necessary. It is advisable in practice to use chained observers as little as possible, in order to protect performance.

h3. Bindings

When you put together Properties and Observers, you end up with Bindings. Bindings serve to link two properties together. For example:

<javascript>
MyApp.userController = SC.Object.create({
  name: null
});

MyApp.mainView = SC.View.create({
  userBinding: SC.Binding.from('MyApp.userController.name')
});

MyApp.userController.set('name', 'Joe');

// The runloop must run

console.log(MyApp.mainView.get('user')); // Joe
MyApp.mainView.set('user', 'Jim');

// The runloop must run

console.log(MyApp.userController.get('name')); // Jim
</javascript>

NOTE: One very important difference between bindings and observers is that observers update almost immediately (see Section 3.1: Observer Notification), while bindings update only at the end of each run loop. This offers considerable improvements in performance, but can be confusing if you are acting outside the normal SproutCore context - for instance, when using a console. See 'The Run Loop' for more details.

In this example, we used the absolute path to the property. Bindings also support relative properties and chained properties as well.

As you can also see, when you update the value in one location, it is updated in the other.

h4. Bindings Shorthand

Since simple bindings are used so often, there's also a shortcut to creating bindings. By default, if you only specify a string for the binding it is created as if you had done +SC.Binding.from(STRING)+. In the above example, you could instead do:

<javascript>
userBinding: 'MyApp.userController.name'
</javascript>

h4. Bindings and Chained Property Paths

Since bindings make use of observers behind the scenes, the same principles of chained observers applies. This means that if you want to observe a chained property, you will want to use asterisks in your path as appropriate.

<javascript>
MyApp.usersController = SC.ArrayController.create({
  mainUser: SC.Object.create({
    name: 'Joe'
  })
});

MyApp.userNameView = SC.LabelView.create({
  valueBinding: 'MyApp.usersController*mainUser.name'
});

MyApp.usersController.setPath('mainUser.name', "Harriet");

// The run loop must run

MyApp.userNameView.get('value'); // "Harriet"

MyApp.usersController.set('mainUser', SC.Object.create({ name: 'Eunice' }));

// The run loop must run

MyApp.userNameView.get('value'); // "Eunice"

</javascript>

Since we used an asterisk in the +valueBinding+ property path, the binding will be updated if either +mainUser+ or +mainUser.name+ changes.

h4. Binding Transforms

By default, Sproutcore creates simple bi-directional bindings.  A change on one property will be relayed to the other side and vice versa with no changes in between.  Sometimes, this behavior isn't exactly what you want.  For example, what if you have an object that expects a Boolean on one side and another object that emits a Number on the other side?

Sproutcore provides an way to implement custom bindings through *binding transforms*.  Transforms convert values that change on one side of the bindings into another value before it is applied to the other side.

|_. Helper |_. Description |
|oneWay()|Forces binding to only relay changes in one direction.  Changes on the "from" side (the path you name as the value) will be relayed to the "to" side (the property you name before "Binding").  Changes in the other direction will not be relayed. |
|bool()|Forces all values to become booleans.  +null+, +undefined+, +0+, and +false+ all become +false+.  All other values become +true+ |
|single()|Forces all values to a non-Enumerable value.  Arrays with one item in them will be converted to that item only.  Arrays with multiple items will be converted to a placeholder value (default +SC.MULTIPLE_PLACEHOLDER+).|
|multiple()|Forces all values to an Array-like value.  +null+ or +undefined+ becomes an empty array.  Single objects will be wrapped in an array.  Arrays and enumerables pass through unchanged.|
|notEmpty()|Does not allow empty values.  +null+, +undefined+, empty strings and empty arrays are converted to a placeholder value (default +SC.EMPTY_PLACEHOLDER+)|
|notNull()|Does not allow +null+ values.  This is a more restricted version of notEmpty()|
|not()|Inverts the transform.  This is equivalent to +bool()+ but the resulting boolean will be inverted.|
|isNull()|Transforms the value to +YES+ if the original value is +null+ or +undefined+ and +NO+ otherwise.  Useful for enabled/disabling UI when you have no content|
|noError()|Ensures no Error objects are allowed through.  Errors will be converted to +null+.|

Transforms can be chained together.  You can use this facility to construct just the type of binding you want.  For example, if you have an object that expects single values only, no errors and no empty values, you could code:
 
<javascript>
userBinding: SC.Binding.from('MyApp.userController.name'.single().noError().notEmpty()
</javascript>

As another example, if you only need a one way binding that is of a boolean type, you could code:

<javascript>
isVisibleBinding: SC.Binding.from('MyApp.userController.isBusy").oneWay().bool()
</javascript>

In addition to using the built-in transforms listed above, you can also add your own transforms.  A transform is simply a function that accepts an untransformed value and returns the transformed value.  It has the following signature.

<javascript>
function(value, isForward) {
  // do transform
  return transformedValue;
}
</javascript>

The first parameter passed to a transform function will be the untransformed +value+.  

If +isForward+ is +YES+, then the value being passed came from the "from" side of the binding (i.e. the "Binding.path" you named).  If +isForward+ is +NO+, then the value came from the "to" side (i.e. the property you named with "propertyBinding").  You can vary your transform behavior if you are based on the direction of the change.

Your transform function should transform the value as needed and return it.  If you don't want to perform any kind of transform, then return the value as it was passed in.

For example, to make a string upper case:

<javascript>
userBinding: SC.Binding.from('MyApp.userController.name')
  .transform(function(value, isForward) {
    return (value && value.toString) ? value.toString().toUpperCase() : '';
  })
</javascript>

If you want use a transform over and over again, you can define a new method on the +SC.Binding+ object like so:

<javascript>
SC.Binding.upperCaseString = function() {
  return this.transform(function(value, isForward) {
    return (value && value.toString) ? value.toString().toUpperCase() : '';
  });
};

...

userBinding: SC.Binding.from('MyApp.userController.name'.upperCaseString())

</javascript>


h4. Manually Creating and Disconnecting Bindings

Most of the time you will setup bindings using the class definition method described above.  Occasionally, however, you may want to setup and teardown bindings yourself.  
 
To create a binding just use the +bind()+ method defined on +SC.Observable+ and inherited by +SC.Object+.  The first parameter you pass should be the property name you want to bind to.  The second is the same thing you would set as the value of a binding property:
 
<javascript>
myView.bind('isVisible', SC.Binding.from('MyApp.mainController.title').bool());
 
// is the same as
 
myView = SC.View.create({
  isVisibleBinding: SC.Binding.from('MyApp.mainController.title').bool()
});
</javascript>
 
Note that when you manually create a binding, the +BindingDefaults+ property is not consulted.  You must configure the binding exactly as you need.

If you have created a binding and need to disconnect it for some reason, you can call the +disconnect()+ method on the binding itself.

If you manually create a binding using bind(), the actual binding object is returned from the bind() call.

If you create a binding by defining it on your class, you can find the binding instance on the same property on an object instance:

<javascript>
var binding = myView.bind('isVisible', SC.Binding.from('MyApp.mainController.title').bool());
 
// is the same as
 
myView = SC.View.create({
  isVisibleBinding: SC.Binding.form('MyApp.mainController.title').bool()
});
var binding = myView.get('isVisibleBinding');
 
// disconnect!
binding.disconnect();
</javascript>

You can reconnect a binding that has been disconnected using the +connect()+ method as well.


h3. The Run Loop

You will rarely have to reference the Run Loop in your app itself. However, you may find it useful in debugging and will likely have to use it in your unit tests. It's also worth gaining an understanding of it to understand more about how your app works.

The run loop coordinates all the events within your application. This includes primarily observers and timers. This helps make sure that events stay synchronized and run at the proper times. One of the main ways this will affect your app is that bindings do not fire until the Run Loop has fired.

SproutCore manages the run loop for you automatically triggering when it receives any browser events or user input. The only case in which you will have to manage the run loop from within your app is if you have a callback from an external library that is not managed by SproutCore. In this circumstance, you will want to trigger a new run loop by wrapping the code in +SC.RunLoop.begin()+ and +SC.RunLoop.end()+. This will create a new run loop for that bit of code and will make sure all events are fired upon completion.

When working with unit tests, you will also have situations where you need to force bindings and observers to update so you can check for the correct results. In these cases, it is completely legitimate to manually invoke the run loop. Normally user events would trigger the run loop, but since your tests are automated, there are no user events taking place.

You may also find that when you are working in your browser's JavaScript console that, when you set a variable, your app's interface doesn't update as you expect. This may be caused by the run loop not firing (since you aren't interacting directly with the app no events are being triggered). In this case you should try invoking the run loop manually, or just move your mouse over the app to trigger a new event.

WARNING: Remember, you rarely need to manage the run loop manually from within your app. If you aren't certain of why you are using it, then you are probably doing something wrong. The average user should use the run loop only in Unit Tests or in the console.

h3. Changelog

* January 12, 2011: initial partial version by "Peter Wagenet":credits.html#pwagenet
* January 19, 2011: further updates by "Peter Wagenet":credits.html#pwagenet
* January 20, 2011: corrections to "The +init+ Method" and "The Run Loop" by "Peter Wagenet":credits.html#pwagenet
* January 24, 2011: added section on "Bindings and Chained Property Paths" by "Peter Wagenet":credits.html#pwagenet
* March 2, 2011: fixed paragraph formmatting by "Topher Fangio":credits.html#topherfangio
* March 2, 2011: fixed grammar, clarified phrasing, added examples to the Observer section by "Jason Gignac":credits.html#jgignac
* April 13, 2011: "Binding Transforms" and "Manually Creating and Disconnecting Bindings" sections copied from wiki and edited by "Vibul Imtarnasan":credits.html#veebs
